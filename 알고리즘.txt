! 냅색 알고리즘 : n개 중 몇개만 뽑아서 가장 최댓값을 만듦
                  (2차원 dp 배열로 위에거를 바로쓸지 j를 1~k까지 둔다. 현재값과 이전에서 사용한 값을 더한 값이랑 위에거를 바로쓰는것을 비교
                   max(dp[i-1][j], 현재값 + dp[i-1][j-w])

! DFS + DP : 1. dfs 탐색을 줄이는 방법이다. 탐색했던 곳을 또 탐색할 필요가 없을 때 사용
             (방문배열 초기값을 -1로 두고 방문은 0, 실패는 1, 성공은 2로 기록해두고 dfs로 들어갔을 때 배열 값이 -1이 아니라면
             return하는 방식이다. dfs를 하기 전 visit를 0으로 바꾸고 return 되어서 나올 때 성공인지 실패인지 값을 저장한다.
             if visit[x][y] != -1:
                 state 값 바꾸고
                 return
             visit[x][y] = 0
             dfs(x, y)
             visit[x][y] = state(전역변수로 컨트롤)
             )

           : 2. dfs 탐색을 줄이는 방법
            (방문배열 초기값을 -1로 두고 방문을 했으면 1로 처음 둔다. 그리고 dfs 탐색을 상,하,좌,우로 하는데 visit의 값은 현재 값과
            dfs방문을 했을 때 +1 값 중에서 큰 값을 저장한다.)
            if visit[x][y] != -1:
                return visit[x][y]
            for i in range(4):
                4방향
                visit[x][y] = max(visit[x][y], dfs(nx, ny) + 1)
            return visit[x][y]

! 구현 : 구현문제는 문제 분석이 중요!(문제를 정확히 이해해야함)

! 시계방향, 반시계방향 : 전 좌표와 후 좌표를 비교해서 for문 4개로 구현(왼쪽 열, 오른쪽 열, 위에 행, 밑에 행)

! 위상정렬 : 방향 비순환 그래프 / 순서에 맞춰서 출력 or 계산 해야할때
             자신을 향하는 간선 개수를 저장해놓고 개수가 0이라면 큐에 넣고
             방문을 당한다면 개수를 하나씩 줄이면서 반복한다

! 위상정렬 + dp : 방향 비순환 그래프 + 다이나믹 프로그래밍 / 순서에 맞춰야되고 다른 것이 오기 전 까지 가지 못함
                  건물을 순서대로 짓는 문제인데 전체적인 구조는 위상정렬을 사용한다.
                  0인 정점을 넣을 때 다음 dp 배열에는 dp[다음 정점] = max(dp[다음 정점], dp[현재 정점] + time[다음 정점])
                  이렇게 최댓값을 넣어준다. 왜냐하면 dp의 현재 값에는 가장 큰 값이 있어야 한다(건물이 다 지어져야 하기 때문)

! 투포인터 : n의 제한이 높고 두개?를 더해서 어떤 값이 나와야한다. 최소로 나와야한다.
             이러면 투포인터를 의심해 볼 수 있음. 정렬!
             st와 ed가 0, 0 에서 토끼와 거북이처럼 같이 출발하는 것과 0, n-1 에서 서로 다가오는 것이 있다.


! 스택 : n의 제한이 높고 앞에거와 뒤에거를 비교하거나 계속 필요하다면 스택을 의심해 볼 필요가 있음
         스택은 넣거나 빼는 경우 이 두가지만 생각하면 된다.

! 백트래킹 + 그래프 탐색 : 백트래킹 함수의 매개변수에 idx를 주고 시간을 줄이고 백트래킹에서 조합을 만들었다면 그래프탐색으로
                           해당 노드들이 이어져있는지 확인하면 된다. 나는 bfs를 이용해서 확인했음

! DFS(재귀)에서 return 값 받기 : 1. 탐색 중간에 false가 되어서 답을 false로 return 해야하면
                                 
                                 answer = dfs()
                                 if not answer:
                                     return False
                                 return True

                                 이렇게 answer가 재귀적인 수행이기 때문에 잘 생각해보면 밑에 if문을 준다면 계속적인 false를 return 할 수 있음

                                 2. dfs로 방문한 개수를 다 가지고 return

                                 c = 1
                                 for ~
                                    c += dfs() # 현재 위치에서 방문했던 것을 다 더함
                                 return c # 다 더한 후 return 함

! 이분탐색 : 구간 나누기(구간의 최댓값 중 최솟값 찾기)
             이분탐색으로 찾을 때 mid값을 현재 구간 까지의 최댓값 - 최솟값으로 컨트롤한다.
             현재 구간 까지의 최댓값 - 최솟값이 mid보다 크다면 cnt +1을 한다.
             for문을 다 돌았을 때 cnt가 구해야하는 구간보다 크다면 l을 늘린다.(구간의 개수가 더 줄어듬)
             작거나 같다면 답을 구하고 r을 줄인다.(최솟값을 구해야하기 때문에 줄여야함 여기서 답 갱신)


! DP : 배열에서 가장 큰 정사각형, 위에서 아래로만 내려온다, 그 전값을 계속 써야한다. 그러면 dp 의심해야함 그리고 그 전 값을 어떻게 잘 이용할지

! 보석 도둑(Heap) : 보석의 무게가 가볍고 가치가 높은 것을 가방 무게가 최소인 것에 넣어야 함
                    # 둘 다 오름차순으로 정렬 후 최대힙을 사용하는 리스트를 하나 생성
                    # 반복문을 가방을 기준으로 돌면서 가방의 무게가 현재 보석보다 더 커질 때 까지 보석을 최대힙에 넣음
                    # 그러면 힙에는 현재 가방 무게까지 구할 수 있는 보석 무게 중 최댓값이 저장되어있음
                    # 그래서 힙에서 하나씩 빼주면 답을 구할 수 있음(힙을 하나 더 사용을 했어야하는데 입력에 주어진 리스트 2개로 답을 구하려다보니 생각이 많아짐)
