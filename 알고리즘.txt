! 냅색 알고리즘 : n개 중 몇개만 뽑아서 가장 최댓값을 만듦
                  (2차원 dp 배열로 위에거를 바로쓸지 j를 1~k까지 둔다. 현재값과 이전에서 사용한 값을 더한 값이랑 위에거를 바로쓰는것을 비교
                   max(dp[i-1][j], 현재값 + dp[i-1][j-w])

! DFS + DP : 1. dfs 탐색을 줄이는 방법이다. 탐색했던 곳을 또 탐색할 필요가 없을 때 사용
             (방문배열 초기값을 -1로 두고 방문은 0, 실패는 1, 성공은 2로 기록해두고 dfs로 들어갔을 때 배열 값이 -1이 아니라면
             return하는 방식이다. dfs를 하기 전 visit를 0으로 바꾸고 return 되어서 나올 때 성공인지 실패인지 값을 저장한다.
             if visit[x][y] != -1:
                 state 값 바꾸고
                 return
             visit[x][y] = 0
             dfs(x, y)
             visit[x][y] = state(전역변수로 컨트롤)
             )

           : 2. dfs 탐색을 줄이는 방법
            (방문배열 초기값을 -1로 두고 방문을 했으면 1로 처음 둔다. 그리고 dfs 탐색을 상,하,좌,우로 하는데 visit의 값은 현재 값과
            dfs방문을 했을 때 +1 값 중에서 큰 값을 저장한다.)
            if visit[x][y] != -1:
                return visit[x][y]
            for i in range(4):
                4방향
                visit[x][y] = max(visit[x][y], dfs(nx, ny) + 1)
            return visit[x][y]

! 구현 : 구현문제는 문제 분석이 중요!(문제를 정확히 이해해야함)

! 시계방향, 반시계방향 : 전 좌표와 후 좌표를 비교해서 for문 4개로 구현(왼쪽 열, 오른쪽 열, 위에 행, 밑에 행)

! 위상정렬 : 방향 비순환 그래프 / 순서에 맞춰서 출력 or 계산 해야할때
             자신을 향하는 간선 개수를 저장해놓고 개수가 0이라면 큐에 넣고
             방문을 당한다면 개수를 하나씩 줄이면서 반복한다

! 위상정렬 + dp : 방향 비순환 그래프 + 다이나믹 프로그래밍 / 순서에 맞춰야되고 다른 것이 오기 전 까지 가지 못함
                  건물을 순서대로 짓는 문제인데 전체적인 구조는 위상정렬을 사용한다.
                  0인 정점을 넣을 때 다음 dp 배열에는 dp[다음 정점] = max(dp[다음 정점], dp[현재 정점] + time[다음 정점])
                  이렇게 최댓값을 넣어준다. 왜냐하면 dp의 현재 값에는 가장 큰 값이 있어야 한다(건물이 다 지어져야 하기 때문)

! 투포인터 : n의 제한이 높고 두개?를 더해서 어떤 값이 나와야한다. 최소로 나와야한다.
             이러면 투포인터를 의심해 볼 수 있음. 정렬!
             st와 ed가 0, 0 에서 토끼와 거북이처럼 같이 출발하는 것과 0, n-1 에서 서로 다가오는 것이 있다.


