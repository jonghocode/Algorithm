! 냅색 알고리즘 : n개 중 몇개만 뽑아서 가장 최댓값을 만듦
                  (2차원 dp 배열로 위에거를 바로쓸지 j를 1~k까지 둔다. 현재값과 이전에서 사용한 값을 더한 값이랑 위에거를 바로쓰는것을 비교
                   max(dp[i-1][j], 현재값 + dp[i-1][j-w])

! DFS + DP : dfs 탐색을 줄이는 방법이다. 탐색했던 곳을 또 탐색할 필요가 없을 때 사용
             (방문배열 초기값을 -1로 두고 방문은 0, 실패는 1, 성공은 2로 기록해두고 dfs로 들어갔을 때 배열 값이 -1이 아니라면
             return하는 방식이다. dfs를 하기 전 visit를 0으로 바꾸고 return 되어서 나올 때 성공인지 실패인지 값을 저장한다.
             if visit[x][y] != -1:
                 state 값 바꾸고
                 return
             visit[x][y] = 0
             dfs(x, y)
             visit[x][y] = state(전역변수로 컨트롤)
             )

! 구현 : 구현문제는 문제 분석이 중요!(문제를 정확히 이해해야함)

! 시계방향, 반시계방향 : 전 좌표와 후 좌표를 비교해서 for문 4개로 구현(왼쪽 열, 오른쪽 열, 위에 행, 밑에 행)

! 위상정렬 : 방향 비순환 그래프 / 순서에 맞춰서 출력 or 계산 해야할때
             자신을 향하는 간선 개수를 저장해놓고 개수가 0이라면 큐에 넣고
             방문을 당한다면 개수를 하나씩 줄이면서 반복한다
             