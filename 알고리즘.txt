! 냅색 알고리즘 : n개 중 몇개만 뽑아서 가장 최댓값을 만듦
                  (2차원 dp 배열로 위에거를 바로쓸지 j를 1~k까지 둔다. 현재값과 이전에서 사용한 값을 더한 값이랑 위에거를 바로쓰는것을 비교
                   max(dp[i-1][j], 현재값 + dp[i-1][j-w])

! DFS + DP : 1. dfs 탐색을 줄이는 방법이다. 탐색했던 곳을 또 탐색할 필요가 없을 때 사용
             (방문배열 초기값을 -1로 두고 방문은 0, 실패는 1, 성공은 2로 기록해두고 dfs로 들어갔을 때 배열 값이 -1이 아니라면
             return하는 방식이다. dfs를 하기 전 visit를 0으로 바꾸고 return 되어서 나올 때 성공인지 실패인지 값을 저장한다.
             if visit[x][y] != -1:
                 state 값 바꾸고
                 return
             visit[x][y] = 0
             dfs(x, y)
             visit[x][y] = state(전역변수로 컨트롤)
             )

           : 2. dfs 탐색을 줄이는 방법(메모이제이션 : 끝까지 가야함)
            (방문배열 초기값을 -1로 두고 방문을 했으면 1로 처음 둔다. 그리고 dfs 탐색을 상,하,좌,우로 하는데 visit의 값은 현재 값과
            dfs방문을 했을 때 +1 값 중에서 큰 값을 저장한다.)
            if visit[x][y] != -1:
                return visit[x][y]
            for i in range(4):
                4방향
                visit[x][y] = max(visit[x][y], dfs(nx, ny) + 1)
            return visit[x][y]

! 구현 : 구현문제는 문제 분석이 중요!(문제를 정확히 이해해야함)

! 시계방향, 반시계방향 : 전 좌표와 후 좌표를 비교해서 for문 4개로 구현(왼쪽 열, 오른쪽 열, 위에 행, 밑에 행)

! 위상정렬 : 방향 비순환 그래프 / 순서에 맞춰서 출력 or 계산 해야할때
             자신을 향하는 간선 개수를 저장해놓고 개수가 0이라면 큐에 넣고
             방문을 당한다면 개수를 하나씩 줄이면서 반복한다

! 위상정렬 + dp : 방향 비순환 그래프 + 다이나믹 프로그래밍 / 순서에 맞춰야되고 다른 것이 오기 전 까지 가지 못함
                  건물을 순서대로 짓는 문제인데 전체적인 구조는 위상정렬을 사용한다.
                  0인 정점을 넣을 때 다음 dp 배열에는 dp[다음 정점] = max(dp[다음 정점], dp[현재 정점] + time[다음 정점])
                  이렇게 최댓값을 넣어준다. 왜냐하면 dp의 현재 값에는 가장 큰 값이 있어야 한다(건물이 다 지어져야 하기 때문)

! 투포인터 : n의 제한이 높고 두개?를 더해서 어떤 값이 나와야한다. 최소로 나와야한다.
             이러면 투포인터를 의심해 볼 수 있음. 정렬!
             st와 ed가 0, 0 에서 토끼와 거북이처럼 같이 출발하는 것과 0, n-1 에서 서로 다가오는 것이 있다.


! 스택 : n의 제한이 높고 앞에거와 뒤에거를 비교하거나 계속 필요하다면 스택을 의심해 볼 필요가 있음
         스택은 넣거나 빼는 경우 이 두가지만 생각하면 된다.

! 백트래킹 + 그래프 탐색 : 백트래킹 함수의 매개변수에 idx를 주고 시간을 줄이고 백트래킹에서 조합을 만들었다면 그래프탐색으로
                           해당 노드들이 이어져있는지 확인하면 된다. 나는 bfs를 이용해서 확인했음

! DFS(재귀)에서 return 값 받기 : 1. 탐색 중간에 false가 되어서 답을 false로 return 해야하면
                                 
                                 answer = dfs()
                                 if not answer:
                                     return False
                                 return True

                                 이렇게 answer가 재귀적인 수행이기 때문에 잘 생각해보면 밑에 if문을 준다면 계속적인 false를 return 할 수 있음

                                 2. dfs로 방문한 개수를 다 가지고 return

                                 c = 1
                                 for ~
                                    c += dfs() # 현재 위치에서 방문했던 것을 다 더함
                                 return c # 다 더한 후 return 함

! 이분탐색 : 구간 나누기(구간의 최댓값 중 최솟값 찾기)
             이분탐색으로 찾을 때 mid값을 현재 구간 까지의 최댓값 - 최솟값으로 컨트롤한다.
             현재 구간 까지의 최댓값 - 최솟값이 mid보다 크다면 cnt +1을 한다.
             for문을 다 돌았을 때 cnt가 구해야하는 구간보다 크다면 l을 늘린다.(구간의 개수가 더 줄어듬)
             작거나 같다면 답을 구하고 r을 줄인다.(최솟값을 구해야하기 때문에 줄여야함 여기서 답 갱신)


! DP : 배열에서 가장 큰 정사각형, 위에서 아래로만 내려온다, 그 전값을 계속 써야한다. 그러면 dp 의심해야함 그리고 그 전 값을 어떻게 잘 이용할지

! 보석 도둑(Heap) : 보석의 무게가 가볍고 가치가 높은 것을 가방 무게가 최소인 것에 넣어야 함
                    # 둘 다 오름차순으로 정렬 후 최대힙을 사용하는 리스트를 하나 생성
                    # 반복문을 가방을 기준으로 돌면서 가방의 무게가 현재 보석보다 더 커질 때 까지 보석을 최대힙에 넣음
                    # 그러면 힙에는 현재 가방 무게까지 구할 수 있는 보석 무게 중 최댓값이 저장되어있음
                    # 그래서 힙에서 하나씩 빼주면 답을 구할 수 있음(힙을 하나 더 사용을 했어야하는데 입력에 주어진 리스트 2개로 답을 구하려다보니 생각이 많아짐)

! MST(최소 신장 트리) : 모든 node를 연결하는데 필요한 비용을 최소로 구하는 알고리즘
                        프림 : 2차원 배열 이용(q 사용), 인접 리스트 이용(힙 사용)
                        힙(
                            visit = [0 for _ in range(n)]
                            cost = [INF for _ in range(n)]
                            cost[0] = 0
                            q = []
                            heappush(q, (0, 0))
                            while q:
                                T, now = heappop(q)
                                if visit[now] == 0:
                                    visit[now] = 1
                                    for weight, idx in graph[now]:
                                        if visit[idx] == 0 and cost[idx] > weight:
                                            cost[idx] = weight
                                            heappush(q, (weight, idx))
                            answer = sum(cost)
                        )

                        큐에 넣을 때 튜플 사용해야함(리스트보다 6배 빠름)

! 트리의 지름 : 트리의 지름은 2가지 방법이 있다.
             먼저 첫 번째 방법은 아무 노드에서 출발해서 가장 가중치 or 거리가 먼 노드를 구한다.
             그리고 찾은 노드에서 한 번더 dfs를 돌려서 나온 값이 트리의 지름이다. 이렇게 dfs 2번을 돌리는 방법과

             두 번째 방법도 일단 아무 노드에서 출발한다. 그리고 깊이를 끝까지 간 다음 return 되어져서 돌아올 때
             하나의 노드에서 뻗어져 나간 간선들 중에 가장 값이 높은 값만 return을 해준다. 그렇게 2개의 간선으로 최댓값을 구해주면 된다.

! LCA : 두 노드의 최소공통조상을 구하기
        저장해야 할 값 : 각 노드의 부모와 깊이
        1. 두 노드의 깊이를 맞춰준다.
        2. 깊이가 같다면 부모가 같은지 본다.
        3. 부모가 같다면 종료
        3. 부모가 다르다면 2개의 깊이를 같이 올린다.

! 위상정렬 : 방향성, 작업 순서(작업 순서 못 정하면 사이클이 있는거), 최장 경로
           1. 자신으로 들어오는 간선 개수 구하기
           2. 간선의 개수가 0인 것들을 큐에 넣고 계속 반복

           최장 경로를 구하려면 dp를 이용해서 최댓값을 넣어주면 된다.
           dp[다음 노드] = max(dp[다음 노드], dp[현재 노드] + 가중치)

           역추적은 현재 값에서 가중치를 뺐을 때 그 전 값과 같은것을 계속 큐에 넣으면서 추적하면 됨

! 메모이제이션 : 메모이제이션은 끝까지 갔다가 돌아오면서 기록한다.

! 유니온 파인드 : 1. 부모 리스트를 만든다(초기값은 자기자신)
               2. find함수를 돌린다
               ex) find(idx):
                       if parent[idx] == idx:
                           return parent[idx]
                        parent[idx] = find(parent[idx])
                        return parent[idx]
               3. 합친다
                   if n1 != n2:
                       parent[n2] = n1
               4. 두 노드의 부모가 같은지 보려면 find함수를 호출해서 검사한다.

! 크루스칼 : 최소 스패닝 트리(최소의 비용으로 모든 노드를 이을 수 있는 트리)를 구할 때 사용
           1. 간선의 비용이 작은 값 부터 union find로 합침(정렬 필요)
           2. 노드의 개수 -1 만큼 합쳤다면 종료(5개 노드가 있었다면 4번만 합치면 됨)

! 해싱 : 직접 해시함수를 만들어서 사용(나누는 나머지의 크기만큼 리스트를 만들어서 써야함)

! 희소배열 : 트리의 시간복잡도를 최악으로 잡는다면 n이다(자식과 부모가 하나씩만 있고 길이가 n인 경우)
           이런 경우에 시간복잡도를 log n으로 바꿀 수 있는 방법이 희소배열이다.
           ex) 건너 뛸 수 있는 경우를 빠르게 구하려면 비트 연산으로 구하면 좋다. 예를 들어 LCA문제를 풀 때 깊이 차이가
           5라면 5 & 1 << j 이런식으로 비트 연산자를 이용하면 빠르다

           1. 길이가 n이라면 희소배열의 크기를 정하기 위해서 n이 2의 몇 승인지 구해야한다.
           2. 희소배열의 초기값은 dp[0]번째 배열에는 각각의 그래프 값을 넣는다.(자신의 부모와 가중치)
           3. for문으로 1부터 1번에서 구한 값 까지 희소배열을 만든다.
           4. 희소배열은 부모의 부모만 바라보면서 만든다. -> 부모의 부모를 계속해서 바라본다면 2^n승으로 증가한다. 2 -> 4 -> 8

! 세그먼트 트리 : 특정 구간의 합을 log n의 시간복잡도로 구할 수 있는 자료구조다.
               트리의 크기를 잡을 때에는 n의 범위를 2의 승수로 바꾸었을 때의 수에서 2를 한번 더 곱해주면 된다.
               세그먼트 트리는 2가지 동작인 update와 query로 나뉜다. 먼저 update는
               새로운 수가 들어왔을 때 트리의 구조를 새로 바꿔주는 작업이다.
               이 update는 재귀로 구현한다.
               1. update
               def update(l, r, d, k):
                   if l > d or r < d:
                       return tree[k]
                   if l == d and r == d:
                        tree[k] = d
                        return tree[k]
                    mid = (l + r) // 2
                    tree[k] = update(l, mid, d, k*2) + update(mid+1, r, d, k*2+1)
                    return tree[k]
                이런 구조이다.

                두 번째인 query도 재귀로 구현하면 된다.
                n이 주어졌을 때 트리의 범위는
                t = 1; cnt = 0
                while t <= n:
                    t*=2
                    cnt += 1
                이렇게 한 후 1 << (cnt+1)이 트리의 범위이다
                그리고 query를 할 때의 범위는 1~n이 아니라 1~t까지 해야한다. 
                2. query
                def query(l, r, st, ed, k):
                    if st <= l and r <= ed:
                        return tree[k]
                    if l > ed or r < st:
                        return 0
                    mid = (l + r) // 2
                    return query(l, mid, st, ed, k*2) + query(mid+1, r, st, ed, k*2+1)
                이런 구조이다.
                이렇게 2가지 동작을 문제에 맞게 변형시키면서 세그먼트 트리를 사용하면 된다.

! 비트마스킹(bit) : 비트마스킹은 chk를 할 때 시간복잡도와 공간복잡도를 확연히 줄일 수 있는 방법이다.
            먼저 1을 방문체크 해야 한다면 비트연산자의 or를 이용해서 이런식으로 할 수 있다.
            chk = 0
            chk = chk | (1 << 0)

            1의 방문을 해제 해야 한다면 and연산자와 not연산자를 이용하면 된다.
            chk = chk & ~(1 << 0)

            방문했는지 확인하는 것은 and연산자를 이용하면 된다.
            if chk & (1 << 0)

            그리고 비트연산자를 이용한다면 모든경우의수를 아주 간단하게 구현할 수 있다.


! 벨만포드 : 다이나믹, 사이클 확인 가능, 음수 간선, 시간 복잡도(V * E)
           v-1번 경화, 1번 경화

           MAX = int(1e12)
           dis = [MAX for i in range(n+1)]
           dis[1] = 0  -> 출발하는 곳은 0으로 해줘야함

           for i in range(1, n+1):
               sw = 0   -> 무한히 도는지 안도는지 확인하기 위해서
               for j in range(graph):
                  a, b, c = j  -> a에서 b까지 c만큼의 비용
                  if dis[a] == MAX: continue
                  if dis[b] > dis[a] + c:
                      dis[b] = dis[a] + c
                      sw = 1

           if sw == 1: 무한히 돔
           if dis[num] == MAX: 갈 수 없음

! 플로이드 : 다이나믹, 정점의 개수가 500이하일때 가능, 시간 복잡도(v^3), 최솟값도 구할 수 있지만 최댓값도 구할 수 있다.
           현재 정점 -> 현재 정점으로 가는 값은 0으로 바꾸고
           3중 for문으로 구현한다.
           for k in range(1, n+1): # k를 경유해서 간다.
               for i in range(1, n+1):
                   for j in range(1, n+1):
                       MAP[i][j] = min(MAP[i][j], MAP[i][k] + MAP[k][j]) # i에서 j로 갈 때 k를 경유해서 가는것 ik, kj
